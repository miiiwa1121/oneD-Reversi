# 1D-Reversi1次元リバーシのルールに従って、C言語でCLIアプリを実装する方法を解説します。

問題の整理
 1. 初期状態：左が黒 (b)、右が白 (w) の2つの石がある。
 2. 操作：
 • R → 右側に石を置く
 • L → 左側に石を置く
 • 石を置くたびに、直近の同じ色の石までの間にある石をすべてひっくり返す（ただし、隣接する石が同色の場合はひっくり返さない）。
 • 黒 (b) と白 (w) を交互に置く。

実装方針
 1. 配列を使って盤面を管理
 • 盤面を char board[20000] のような配列で管理（最大 10000 + 初期配置 2 くらいを想定）。
 • 初期配置は board[mid] = 'b', board[mid + 1] = 'w' で中央付近に設置。
 2. 操作を順番に適用
 • R の場合：右側 (right) に新しい石を置く
 • L の場合：左側 (left) に新しい石を置く
 • 石を置いた後、最も近い同じ色の石までの間の石をひっくり返す。
 3. 最終的な b と w の数をカウント

コードのポイント
 1. 固定長の配列 board[MAX_SIZE] を用意
 • mid = MAX_SIZE / 2 の位置に初期配置 (b と w)
 • left と right を用いて配置の範囲を管理
 2. L と R による処理
 • L なら left-- して石を置く
 • R なら right++ して石を置く
 • 石を置いた後、間の石をひっくり返す
 3. 最終的な b と w をカウント
 • left から right の範囲を走査し、b と w の数をカウント

入出力例

入力

RRLL

処理の流れ

初期:  bw
1手目:  bbbw   (Rでb)
2手目:  bbbww  (Rでw)
3手目:  bbbwww (Lでb)
4手目:  wwwwww (Lでw) ← ひっくり返る

出力

0 6

計算量と効率
 • O(N) で処理可能（N は棋譜の長さ）
 • board は最大 10000 + 2 なので十分なメモリを確保

このコードを main.c に書いてコンパイル (gcc main.c -o myApp) すれば、

./myApp < input.in

のように実行できます。




### 1. judge.cの概要
盤面を石一つ一つの配列として扱うのではなく、`{色, 個数}` のペアで表現される**ブロックの集まり**として管理しました。
この方法により、何十万個の石がひっくり返る場合でも、ブロック単位で計算できるため、処理がシンプルになります。
これらのブロックを両端から追加・削除できるデックで管理します。

-----

### 2. プログラムの主な流れ

#### ① 初期化

最初に、入力文字列 `S` を読み取り、これをブロックのデックに変換します。例えば `S = "wwb"` であれば、デックは `[{'w', 2}, {'b', 1}]` となります。

```c
// 石の色の連続したブロックを表す構造体
typedef struct {
    char color;      // 石の色 ('b' または 'w')
    long long count; // その色が連続している数
} Block;

// ...

// 1. 初期盤面Sからブロックのデックを構築する
if (s_len > 0) {
    // ... Sをスキャンしてブロックに変換 ...
}
```

-----

#### ② 操作の処理

次に入力文字列 `T` の操作を一つずつ実行します。

##### **同じ色の石に隣接して置く場合**

置く石の色が、隣接するブロックの色と同じ場合、ルール上ひっくり返しは起こりません。そのため、そのブロックの個数を1つ増やすだけで処理は完了します。

```c
// 例：左端に置く場合
if (deque[head].color == current_color) {
    deque[head].count++; // 隣接ブロックの個数を増やす
}

// 例：右端に置く場合
if (deque[tail].color == current_color) {
    deque[tail].count++;
```

##### **相手の色の石に隣接して置く場合**

相手の色のブロックに隣接して石を置くと、「置いた石と、最も近い同じ色の石の間にある石を全てひっくり返す」というルールが発生します。

これをブロックで考えると、**隣接する相手色のブロックを全て自分の色に変え、最も近い自分の色のブロックと統合する**処理になります。

```c
// 例：左端に置く場合
} else {
    // 盤面に相手色のブロックしかない場合、ひっくり返しは起きない
    if (head == tail) {
        // 新しいブロックとして左端に追加する
        head--;
        deque[head] = (Block){current_color, 1};
    } else {
        // 隣の相手色ブロックをひっくり返す
        long long flip_count = deque[head].count; // ひっくり返す石の数
        head++; // 相手色ブロックをデックから取り除く
        
        // その隣の自分の色のブロックに、ひっくり返した石と新しい石を統合する
        deque[head].count += flip_count + 1;
    }
}
```
-----

#### ③ 結果の集計

全ての操作 `T` が完了した後、デック内に残っている各ブロックの情報を基に、黒石と白石の総数を計算して出力します。

```c
// 3. 最終的な黒石と白石の数を集計する
long long black_count = 0;
long long white_count = 0;
for (int i = head; i <= tail; ++i) {
    if (deque[i].color == 'b') {
        black_count += deque[i].count;
    } else {
        white_count += deque[i].count;
    }
}
```
